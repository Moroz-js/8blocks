name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Deploy via SSH (Docker Compose)
        uses: appleboy/ssh-action@v1.0.0
        env:
          PROJECT_NAME: ${{ secrets.PROJECT_NAME }}
          DOMAIN: ${{ secrets.DOMAIN }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          ADMIN_USERNAME: ${{ secrets.ADMIN_USERNAME }}
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
          GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          command_timeout: 15m
          script_stop: true
          envs: PROJECT_NAME,DOMAIN,POSTGRES_USER,POSTGRES_PASSWORD,POSTGRES_DB,SMTP_HOST,SMTP_PORT,SMTP_USER,SMTP_PASSWORD,SMTP_FROM,ADMIN_USERNAME,ADMIN_PASSWORD,GOOGLE_ANALYTICS_ID
          script: |
            set -euo pipefail
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸš€ Deploying ${PROJECT_NAME}"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            PROJECT_DIR="/var/www/${PROJECT_NAME}"
            
            # Navigate to project directory
            echo "ğŸ“ Entering ${PROJECT_DIR}"
            cd "${PROJECT_DIR}"
            
            # Pull latest changes
            echo "ğŸ“¥ Pulling latest changes from Git"
            git fetch --all
            git reset --hard origin/main
            git pull origin main
            
            # Generate .env file from GitHub Secrets
            echo "âš™ï¸  Generating .env from GitHub Secrets"
            umask 077
            cat > .env <<EOF
            # ============================================
            # Production Environment Variables
            # Auto-generated by GitHub Actions
            # ============================================
            
            # Project
            PROJECT_NAME=${PROJECT_NAME}
            
            # Runtime
            NODE_ENV=production
            
            # URLs (basePath /new is configured in next.config.ts)
            NEXT_PUBLIC_SITE_URL="https://${DOMAIN}/new"
            
            # Database (Docker internal)
            POSTGRES_USER=${POSTGRES_USER}
            POSTGRES_PASSWORD="${POSTGRES_PASSWORD}"
            POSTGRES_DB=${POSTGRES_DB}
            DATABASE_URL="postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?schema=public"
            
            # Email (SMTP via Nodemailer)
            SMTP_HOST=${SMTP_HOST}
            SMTP_PORT=${SMTP_PORT}
            SMTP_USER=${SMTP_USER}
            SMTP_PASSWORD="${SMTP_PASSWORD}"
            SMTP_FROM="${SMTP_FROM}"
            
            # Admin Authentication
            ADMIN_USERNAME=${ADMIN_USERNAME}
            ADMIN_PASSWORD="${ADMIN_PASSWORD}"
            
            # Analytics
            GOOGLE_ANALYTICS_ID=${GOOGLE_ANALYTICS_ID}
            
            # Upload Configuration
            UPLOAD_DIR=public/uploads
            EOF
            chmod 600 .env
            echo "âœ“ .env file created with secure permissions"
            
            # Clean build artifacts and old containers FIRST
            echo "ğŸ§¹ Cleaning old build artifacts"
            rm -rf .next || true
            
            # Aggressive cleanup of Docker state (keep volumes/database)
            echo "ğŸ—‘ï¸  Stopping and removing old containers"
            
            # 1. Try graceful compose down first
            docker compose down --remove-orphans 2>/dev/null || true
            sleep 2
            
            # 2. Force-kill and remove containers by name pattern (handles leftovers)
            for c in $(docker ps -aq --filter "name=${PROJECT_NAME}"); do
              docker rm -f "$c" 2>/dev/null || true
            done
            
            # 3. Remove orphaned network by name
            docker network rm "${PROJECT_NAME}_app-network" 2>/dev/null || true
            
            # 4. Prune any remaining dangling resources
            docker container prune -f 2>/dev/null || true
            docker network prune -f 2>/dev/null || true
            
            # 5. Remove old app image (keep postgres image)
            docker image rm "${PROJECT_NAME}-app:latest" --force 2>/dev/null || true
            
            # 6. Final wait for Docker daemon to settle
            sleep 2
            
            # Prune only old build cache (faster, only >24h old)
            echo "ğŸ—‘ï¸  Pruning old Docker build cache (>24h)"
            timeout 60 docker builder prune -af --filter "until=24h" || echo "âš ï¸  Cache prune skipped or timed out"
            
            # Build application image with no cache
            echo "ğŸ—ï¸  Building application Docker image (no cache)"
            DOCKER_BUILDKIT=1 docker compose build --pull --no-cache app
            
            # Wait for build to settle
            sleep 2
            
            # Start PostgreSQL first with force-recreate
            echo "ğŸ˜ Starting PostgreSQL (force recreate)"
            docker compose up -d --force-recreate postgres
            
            # Wait for PostgreSQL to be ready
            echo "â³ Waiting for PostgreSQL to be ready..."
            for i in {1..60}; do
              if docker compose exec -T postgres pg_isready -U "$POSTGRES_USER" -d "$POSTGRES_DB" >/dev/null 2>&1; then
                echo "âœ“ PostgreSQL is ready"
                break
              fi
              if [ $i -eq 60 ]; then
                echo "âŒ PostgreSQL failed to start in time"
                docker compose logs postgres
                exit 1
              fi
              sleep 2
            done
            
            # Start app container with force-recreate
            echo "ğŸ”„ Starting app container (force recreate)"
            docker compose up -d --force-recreate app
            
            # Wait for app to initialize and check if it's running
            echo "â³ Waiting for app to initialize..."
            for i in {1..30}; do
              if docker compose ps app | grep -q "Up"; then
                echo "âœ“ App container is running"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "âŒ App container failed to start"
                docker compose logs --tail=100 app
                exit 1
              fi
              sleep 2
            done
            
            # Additional wait for app to be ready
            sleep 10
            
            # Check if container is still running (not restarting)
            if ! docker compose ps app | grep -q "Up"; then
              echo "âŒ App container is not running properly"
              docker compose logs --tail=100 app
              exit 1
            fi
            
            # Ensure uploads directory exists with correct permissions
            echo "ğŸ“‚ Ensuring uploads directory exists"
            docker compose exec -T app mkdir -p /app/public/uploads || true
            docker compose exec -T app chmod -R 755 /app/public/uploads || true
            
            # Run database migrations
            echo "ğŸ—„ï¸  Running database migrations"
            docker compose exec -T app npm run db:push || {
              echo "âŒ Database migration failed"
              docker compose logs --tail=100 app
              exit 1
            }
            echo "âœ“ Migrations applied"
            
            # Run database seed (creates initial data if DB is empty)
            echo "ğŸŒ± Running database seed"
            docker compose exec -T app npm run db:seed:prod || echo "âš ï¸  Seed failed or skipped (maybe data already exists)"
            
            # Show container status
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“Š Container Status"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            docker compose ps
            
            # Show recent logs
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“œ Recent Application Logs"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            docker compose logs --tail=60 app
            
            # Health check
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ¥ Health Check"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # Wait a bit for app to be fully ready
            sleep 3
            
            # Check if app responds on /new/ path (trailing slash required with trailingSlash: true)
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:3000/new/ || echo "000")
            if echo "$HTTP_CODE" | grep -qE "^(200|301|302|307|308)$"; then
              echo "âœ… App is responding on http://127.0.0.1:3000/new/ (HTTP $HTTP_CODE)"
            else
              echo "âš ï¸  App returned HTTP $HTTP_CODE (may not be ready yet, this is normal during first start)"
            fi
            
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âœ… Deployment completed successfully!"
            echo "ğŸŒ Site: https://${DOMAIN}/new"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
