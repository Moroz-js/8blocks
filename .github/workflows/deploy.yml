name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Deploy via SSH (Docker Compose)
        uses: appleboy/ssh-action@v1.0.0
        env:
          PROJECT_NAME: ${{ secrets.PROJECT_NAME }}
          DOMAIN: ${{ secrets.DOMAIN }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_SECURE: ${{ secrets.SMTP_SECURE }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
          ADMIN_USERNAME: ${{ secrets.ADMIN_USERNAME }}
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
          GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
          DEPLOY_MODE: ${{ secrets.DEPLOY_MODE }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          command_timeout: 15m
          script_stop: true
          envs: PROJECT_NAME,DOMAIN,POSTGRES_USER,POSTGRES_PASSWORD,POSTGRES_DB,SMTP_HOST,SMTP_PORT,SMTP_SECURE,SMTP_USER,SMTP_PASSWORD,SMTP_FROM,ADMIN_EMAIL,ADMIN_USERNAME,ADMIN_PASSWORD,GOOGLE_ANALYTICS_ID,DEPLOY_MODE
          script: |
            set -euo pipefail

            # Error handler
            error_exit() {
              local line_no=$1
              local last_cmd="${BASH_COMMAND}"
              echo ""
              echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
              echo "โ Deployment failed at line $line_no"
              echo "Last command: $last_cmd"
              echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
              # Show recent docker logs if available
              if command -v docker &> /dev/null; then
                echo "Recent Docker containers:"
                docker ps -a --format "table {{.Names}}\t{{.Status}}" 2>/dev/null || true
              fi
              exit 1
            }
            trap 'error_exit $LINENO' ERR

            # ==========================================
            # Configuration
            # ==========================================
            DEPLOY_MODE="${DEPLOY_MODE:-soft}"
            PROJECT_DIR="/var/www/${PROJECT_NAME}"

            # Validate critical environment variables
            if [ -z "${PROJECT_NAME:-}" ]; then
              echo "โ PROJECT_NAME is not set"
              exit 1
            fi

            if [ -z "${DOMAIN:-}" ]; then
              echo "โ DOMAIN is not set"
              exit 1
            fi

            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            echo "๐ Deploying ${PROJECT_NAME}"
            echo "๐ Mode: ${DEPLOY_MODE}"
            echo "๐ Directory: ${PROJECT_DIR}"
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"

            # ==========================================
            # Pre-flight checks
            # ==========================================
            echo "๐ Running pre-flight checks..."
            
            if ! command -v docker &> /dev/null; then
              echo "โ Docker is not installed or not in PATH"
              exit 1
            fi
            echo "โ Docker found: $(docker --version)"

            if ! docker info &> /dev/null; then
              echo "โ Docker daemon is not running or user lacks permissions"
              echo "Try: sudo usermod -aG docker $USER"
              exit 1
            fi
            echo "โ Docker daemon is accessible"

            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
              echo "โ Docker Compose is not available"
              exit 1
            fi
            echo "โ Docker Compose found"

            if [ ! -d "${PROJECT_DIR}" ]; then
              echo "โ Project directory not found: ${PROJECT_DIR}"
              exit 1
            fi
            echo "โ Project directory exists"

            cd "${PROJECT_DIR}"

            # ==========================================
            # 1. Pull latest code
            # ==========================================
            echo "๐ฅ Pulling latest changes"
            git fetch --all
            git reset --hard origin/main
            git pull origin main

            # ==========================================
            # 2. Generate .env from secrets
            # ==========================================
            echo "โ๏ธ  Generating .env"
            umask 077
            printf '%s\n' "PROJECT_NAME=${PROJECT_NAME}" "NODE_ENV=production" "NEXT_PUBLIC_SITE_URL=https://${DOMAIN}" "POSTGRES_USER=${POSTGRES_USER}" "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}" "POSTGRES_DB=${POSTGRES_DB}" "DATABASE_URL=postgresql://appuser:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?schema=public" "SMTP_HOST=${SMTP_HOST}" "SMTP_PORT=${SMTP_PORT}" "SMTP_SECURE=${SMTP_SECURE}" "SMTP_USER=${SMTP_USER}" "SMTP_PASSWORD=${SMTP_PASSWORD}" "SMTP_FROM=${SMTP_FROM}" "ADMIN_EMAIL=${ADMIN_EMAIL}" "ADMIN_USERNAME=${ADMIN_USERNAME}" "ADMIN_PASSWORD=${ADMIN_PASSWORD}" "GOOGLE_ANALYTICS_ID=${GOOGLE_ANALYTICS_ID}" "UPLOAD_DIR=public/uploads" > .env
            chmod 600 .env
            echo "โ .env created"

            # ==========================================
            # 3. Cleanup (mode-dependent)
            # ==========================================
            echo "๐งน Cleaning old artifacts"
            rm -rf .next 2>/dev/null || true
            echo "โ Cleanup completed"

            echo "๐ Deployment mode: ${DEPLOY_MODE}"
            
            if [ "$DEPLOY_MODE" = "hard" ]; then
              echo "๐ด HARD RESET: wiping all containers, volumes, networks"

              # Stop and remove everything including volumes
              docker compose down -v --remove-orphans 2>/dev/null || true
              sleep 2

              # Force-kill any leftover containers
              for c in $(docker ps -aq --filter "name=${PROJECT_NAME}" 2>/dev/null); do
                docker rm -f "$c" 2>/dev/null || true
              done

              # Remove network, images, prune everything
              docker network rm "${PROJECT_NAME}_app-network" 2>/dev/null || true
              docker container prune -f 2>/dev/null || true
              docker network prune -f 2>/dev/null || true
              docker volume prune -f 2>/dev/null || true
              docker image rm "${PROJECT_NAME}-app:latest" --force 2>/dev/null || true

              sleep 2

              # Build cache prune (non-blocking)
              echo "๐๏ธ  Pruning old build cache"
              timeout 30 docker builder prune -af --filter "until=24h" 2>/dev/null || echo "โ๏ธ  Cache prune skipped"

              # ==========================================
              # HARD: Build โ Start all โ Migrate โ Seed
              # ==========================================
              echo "๐๏ธ  Building Docker image (no cache)"
              DOCKER_BUILDKIT=1 docker compose build --pull --no-cache app
              sleep 2

              echo "๐ Starting PostgreSQL"
              docker compose up -d --force-recreate postgres

              echo "โณ Waiting for PostgreSQL..."
              for i in $(seq 1 60); do
                if docker compose exec -T postgres pg_isready -U "$POSTGRES_USER" -d "$POSTGRES_DB" >/dev/null 2>&1; then
                  echo "โ PostgreSQL is ready"
                  break
                fi
                if [ "$i" -eq 60 ]; then
                  echo "โ PostgreSQL failed to start"
                  docker compose logs postgres
                  exit 1
                fi
                sleep 2
              done

              # Create dedicated app user (avoids ALTER USER issues on superuser)
              echo "๐ค Creating app database user"
              docker compose exec -T postgres psql -U postgres -d "$POSTGRES_DB" -c "CREATE USER appuser WITH PASSWORD '${POSTGRES_PASSWORD}' SUPERUSER;" 2>/dev/null || echo "โ๏ธ  User already exists or creation failed"
              docker compose exec -T postgres psql -U postgres -d "$POSTGRES_DB" -c "GRANT ALL PRIVILEGES ON DATABASE ${POSTGRES_DB} TO appuser;" 2>/dev/null || true
              docker compose exec -T postgres psql -U postgres -d "$POSTGRES_DB" -c "GRANT ALL PRIVILEGES ON SCHEMA public TO appuser;" 2>/dev/null || true
              docker compose exec -T postgres psql -U postgres -d "$POSTGRES_DB" -c "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO appuser;" 2>/dev/null || true
              docker compose exec -T postgres psql -U postgres -d "$POSTGRES_DB" -c "GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO appuser;" 2>/dev/null || true
              echo "โ App user configured"

              echo "๐๏ธ  Running migrations"
              docker compose run --rm -T --no-deps app sh -c "node_modules/.bin/prisma db push --skip-generate" || {
                echo "โ Migration failed"; exit 1
              }
              echo "โ Migrations applied"

              echo "๐ Starting app container"
              docker compose up -d --force-recreate app

            else
              echo "๐ข SOFT DEPLOY: zero-downtime โ old app stays up during build"

              # Ensure postgres is running (don't touch it)
              echo "๐ Checking PostgreSQL status..."
              POSTGRES_STATUS=$(docker compose ps postgres 2>/dev/null || echo "not_found")
              echo "PostgreSQL status: $POSTGRES_STATUS"
              
              if ! echo "$POSTGRES_STATUS" | grep -q "Up"; then
                echo "๐ PostgreSQL not running, starting it"
                docker compose up -d postgres
                for i in $(seq 1 60); do
                  if docker compose exec -T postgres pg_isready -U "$POSTGRES_USER" -d "$POSTGRES_DB" >/dev/null 2>&1; then
                    echo "โ PostgreSQL is ready"
                    break
                  fi
                  if [ "$i" -eq 60 ]; then
                    echo "โ PostgreSQL failed to start"
                    docker compose logs postgres
                    exit 1
                  fi
                  sleep 2
                done
              else
                echo "โ PostgreSQL already running"
              fi

              # Ensure appuser exists (safe to run multiple times)
              echo "๐ค Ensuring app database user exists"
              docker compose exec -T postgres psql -U postgres -d "$POSTGRES_DB" -c "CREATE USER appuser WITH PASSWORD '${POSTGRES_PASSWORD}' SUPERUSER;" 2>/dev/null || echo "โ๏ธ  User already exists"
              docker compose exec -T postgres psql -U postgres -d "$POSTGRES_DB" -c "GRANT ALL PRIVILEGES ON DATABASE ${POSTGRES_DB} TO appuser;" 2>/dev/null || true
              docker compose exec -T postgres psql -U postgres -d "$POSTGRES_DB" -c "GRANT ALL PRIVILEGES ON SCHEMA public TO appuser;" 2>/dev/null || true
              docker compose exec -T postgres psql -U postgres -d "$POSTGRES_DB" -c "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO appuser;" 2>/dev/null || true
              docker compose exec -T postgres psql -U postgres -d "$POSTGRES_DB" -c "GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO appuser;" 2>/dev/null || true
              echo "โ App user configured"

              # Build new image WHILE old app is still serving traffic
              echo "๐๏ธ  Building new Docker image (old app still running)"
              DOCKER_BUILDKIT=1 docker compose build --pull --no-cache app

              # Run migrations via temp container (doesn't affect running app)
              echo "๐๏ธ  Running migrations"
              docker compose run --rm -T --no-deps app sh -c "node_modules/.bin/prisma db push --skip-generate" || {
                echo "โ Migration failed"; exit 1
              }
              echo "โ Migrations applied"

              # Quick swap: stop old app โ start new app (minimal downtime ~2-5s)
              echo "๐ Swapping app container (brief restart)"
              docker compose up -d --force-recreate --no-deps app
            fi

            # ==========================================
            # Wait for app to be healthy
            # ==========================================
            echo "โณ Waiting for app..."
            for i in $(seq 1 30); do
              if docker compose ps app | grep -q "Up"; then
                echo "โ App container is running"
                break
              fi
              if [ "$i" -eq 30 ]; then
                echo "โ App container failed to start"
                docker compose logs --tail=100 app
                exit 1
              fi
              sleep 2
            done

            # Wait for Next.js to be fully ready
            sleep 10

            if ! docker compose ps app | grep -q "Up"; then
              echo "โ App container crashed"
              docker compose logs --tail=100 app
              exit 1
            fi

            # ==========================================
            # 8. Ensure uploads directory (bind mount)
            # ==========================================
            echo "๐ Ensuring uploads directory on host"
            mkdir -p "${PROJECT_DIR}/public/uploads"
            
            # Set permissions for bind mount
            # Docker container runs as UID 1001 (nextjs user)
            # Option 1: Change ownership to UID 1001
            # Option 2: Make writable by all (less secure but works)
            
            # Try to set ownership to container user (UID 1001)
            if command -v chown &> /dev/null; then
              echo "Setting ownership to UID 1001 (nextjs in container)"
              chown -R 1001:1001 "${PROJECT_DIR}/public/uploads" 2>/dev/null || {
                echo "โ๏ธ  Could not chown to 1001:1001, trying current user"
                chown -R $(id -u):$(id -g) "${PROJECT_DIR}/public/uploads" 2>/dev/null || true
              }
            fi
            
            # Ensure directory is writable
            chmod -R 755 "${PROJECT_DIR}/public/uploads"
            
            # Test write permissions
            if [ -w "${PROJECT_DIR}/public/uploads" ]; then
              echo "โ Uploads directory is writable"
            else
              echo "โ๏ธ  Uploads directory may not be writable, using broader permissions"
              chmod -R 777 "${PROJECT_DIR}/public/uploads"
            fi
            
            echo "โ Uploads directory ready at ${PROJECT_DIR}/public/uploads"
            ls -la "${PROJECT_DIR}/public/uploads" || true

            # ==========================================
            # 9. Database seed (mode-dependent, runs LAST)
            # ==========================================
            if [ "$DEPLOY_MODE" = "hard" ]; then
              echo "๐ฑ Running database seed (hard mode โ fresh data)"
              docker compose exec -T app npm run db:seed:prod || echo "โ๏ธ  Seed failed"
            else
              echo "โญ๏ธ  Skipping seed (soft mode โ data preserved)"
            fi

            # ==========================================
            # 10. Status & Health Check
            # ==========================================
            echo ""
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            echo "๐ Container Status"
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            docker compose ps

            echo ""
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            echo "๐ Recent Logs"
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            docker compose logs --tail=30 app

            echo ""
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            echo "๐ฅ Health Check"
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            sleep 3
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:3000/ || echo "000")
            if echo "$HTTP_CODE" | grep -qE "^(200|301|302|307|308)$"; then
              echo "โ App is responding (HTTP $HTTP_CODE)"
            else
              echo "โ๏ธ  App returned HTTP $HTTP_CODE"
            fi

            echo ""
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            echo "โ Deployment completed! (mode: ${DEPLOY_MODE})"
            echo "๐ Site: https://${DOMAIN}"
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
